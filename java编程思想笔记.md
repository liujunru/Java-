# java编程思想

## 对象导论

### 继承

在被继承类添加新方法时，应该仔细考虑是否存在基类也需要这些额外方法的可能性。减少迭代的多余代码量

#### 向上转型：

将导出类看作是他的基类的过程![image-20220419164405807](C:\Users\123\AppData\Roaming\Typora\typora-user-images\image-20220419164405807.png)

#### 单根继承结构

所有的类都继承自单一的基类-Object类。好处：

1）保证所有的对象都具备某些功能，object自带方法

2）所有对象都可以很容易在堆上创建，而参数传递也得到了极大的简化

3）使垃圾会受到额实现变得容易得多。垃圾回收器基于C++的改进，由于对象都保证具有类型信息，因此不会因无法确定对象类型陷入僵局。这对于系统级操作（如异常处理）显得尤为重要，也给变成带来了更大的灵活性。

## 一切都是对象

#### 程序运行时，存储对象的地方都有哪些？

- **寄存器**

  这是最快的存储区，这是最快的存储区，因为它位于不同于其他存储区的地方-处理器内部。数量极其有限，所以需要按需分配。

- **堆栈**

  位于通用Ram(随机访问存储器)中，但通过堆栈指针可以从处理器那里获得直接支持。基本数据类型

- **堆**

  一种通用的内存池（也位于RAM区），用于存放所有的Java对象。跟堆栈相比，编译器不需要知道存储的数据在堆里存活多长时间，比较灵活。但是用堆进行内存分配和清理可能比用堆栈进行存储分配需要的更多的时间。

- **常量存储**

  常量值存放。ROM中

- **非RAM存储**

  流对象和持久化对象。这种存储方式的技巧在于，把对象转化成可以存放在其他媒介上的事物，在需要时可恢复成常规的、基于RAM的对象。

#### Java中数组的安全性体现在哪里

Java确保数组会被初始化，而且不能在他的范围之外被访问。这种范围检查，是以每个数组上少量的内存开销以及运行时的下标检查为代价的。

 boolean默认false,char默认'\u0000'(null)

## 初始化与清理

#### 构造器

为了保证编译器知道该调用哪个方法进行初始化，构造器采用与类相同的名称。

#### 垃圾回收器如何工作

垃圾回收器的思想：对任何活的对象，一定能追溯到其存活的堆栈或者静态存储区之间的引用。

java虚拟机中内存分配以较大的“块”为单位。如果对象较大，就会占用单独的块。有了块之后，垃圾回收器在回收的时候就可以往废弃的块里老被对象了。每个块都用相应的代数来记录他是否还存活。通常，如果块在某处被引用，其代数会增加；垃圾回收器将对上次回收动作之后新分配的块进行整理。这对处理大量短命的临时对象很有帮助。垃圾回收器会定期进行完整的清理动作--大型对象仍然不会被复制（只是代数会增加），内含小型对象的那些块则被复制并整理。java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率降低的话就切换到“标记--清扫”方式；同样java虚拟机会跟踪“标记--清扫”效果，要是堆空间出现很多碎片，就会切换回“停止--复制”方式。这就是“自适应、分代的、停止--复制、标记--清扫”式垃圾回收器。

##### 标记--清扫方式

从堆栈和静态存储区触发，遍历所有的引用，进而找出所有的存活对象。每当找到一个存活对象就对对象做一个标记。当全部标记完成之后，清理才会开始。清理时，没有标记的对象会被释放，不会发生任何肤质。所以剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就要重新整理剩下的对象

##### 停止--复制方式

垃圾回收的时候，程序会被暂停，然后将所有存活的对象从当前堆复制到另一个堆，没有复制的都是垃圾。当对象被复制到新堆时，他们是一个挨着一个，所以新堆保持紧凑排列。

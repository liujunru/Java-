# java编程思想

## 对象导论

### 继承

在被继承类添加新方法时，应该仔细考虑是否存在基类也需要这些额外方法的可能性。减少迭代的多余代码量

#### 向上转型：

将导出类看作是他的基类的过程

![image-20220424213722943](https://gitee.com/liujunrull/image-blob/raw/master/202204242137997.png)

#### 单根继承结构

所有的类都继承自单一的基类-Object类。好处：

1）保证所有的对象都具备某些功能，object自带方法

2）所有对象都可以很容易在堆上创建，而参数传递也得到了极大的简化

3）使垃圾会受到额实现变得容易得多。垃圾回收器基于C++的改进，由于对象都保证具有类型信息，因此不会因无法确定对象类型陷入僵局。这对于系统级操作（如异常处理）显得尤为重要，也给变成带来了更大的灵活性。

## 一切都是对象

#### 程序运行时，存储对象的地方都有哪些？

- **寄存器**

  这是最快的存储区，这是最快的存储区，因为它位于不同于其他存储区的地方-处理器内部。数量极其有限，所以需要按需分配。

- **堆栈**

  位于通用Ram(随机访问存储器)中，但通过堆栈指针可以从处理器那里获得直接支持。基本数据类型

- **堆**

  一种通用的内存池（也位于RAM区），用于存放所有的Java对象。跟堆栈相比，编译器不需要知道存储的数据在堆里存活多长时间，比较灵活。但是用堆进行内存分配和清理可能比用堆栈进行存储分配需要的更多的时间。

- **常量存储**

  常量值存放。ROM中

- **非RAM存储**

  流对象和持久化对象。这种存储方式的技巧在于，把对象转化成可以存放在其他媒介上的事物，在需要时可恢复成常规的、基于RAM的对象。

#### Java中数组的安全性体现在哪里

Java确保数组会被初始化，而且不能在他的范围之外被访问。这种范围检查，是以每个数组上少量的内存开销以及运行时的下标检查为代价的。

 boolean默认false,char默认'\u0000'(null)

## 初始化与清理

#### 构造器

为了保证编译器知道该调用哪个方法进行初始化，构造器采用与类相同的名称。

#### 垃圾回收器如何工作

垃圾回收器的思想：对任何活的对象，一定能追溯到其存活的堆栈或者静态存储区之间的引用。

java虚拟机中内存分配以较大的“块”为单位。如果对象较大，就会占用单独的块。有了块之后，垃圾回收器在回收的时候就可以往废弃的块里老被对象了。每个块都用相应的代数来记录他是否还存活。通常，如果块在某处被引用，其代数会增加；垃圾回收器将对上次回收动作之后新分配的块进行整理。这对处理大量短命的临时对象很有帮助。垃圾回收器会定期进行完整的清理动作--大型对象仍然不会被复制（只是代数会增加），内含小型对象的那些块则被复制并整理。java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率降低的话就切换到“标记--清扫”方式；同样java虚拟机会跟踪“标记--清扫”效果，要是堆空间出现很多碎片，就会切换回“停止--复制”方式。这就是“自适应、分代的、停止--复制、标记--清扫”式垃圾回收器。

##### 标记--清扫方式

从堆栈和静态存储区触发，遍历所有的引用，进而找出所有的存活对象。每当找到一个存活对象就对对象做一个标记。当全部标记完成之后，清理才会开始。清理时，没有标记的对象会被释放，不会发生任何肤质。所以剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就要重新整理剩下的对象

##### 停止--复制方式

垃圾回收的时候，程序会被暂停，然后将所有存活的对象从当前堆复制到另一个堆，没有复制的都是垃圾。当对象被复制到新堆时，他们是一个挨着一个，所以新堆保持紧凑排列。

#### 静态数据是何时被初始化的

静态初始化只有在必要时刻才会进行。第一次访问静态数据的时候才会被初始化，此后静态对象不会再被初始化。

初始化的顺序是先静态对象（如果之前未被初始化），然后是“非静态”对象。

#### 对象的创建过程

1. 假设有个Dog的类。即使没有显式的使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时（构造器可以看成静态方法），或者Dog类的静态方法、静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件
2. 然后加载Dog.class，创建一个class对象，有关静态初始化的所有动作都会执行。因此，静态初始化只在class对象首次加载的时候进行一次
3. 当用new Dog()创建对象的时候，首先在堆上为Dog对象分配足够的存储空间
4. 这块存储空间会被清零，这就自动的将Dog对象中的所有基本类型设置为默认值，引用设为null
5. 执行所有出现于字段定义处的初始化动作
6. 执行构造器

#### 数组初始化

数字赋值是复制的引用

## 访问控制权限

#### java解释器的运行过程

首先找出环境变量CLASSPATH（可以通过操作系统来设置，有时也可以通过安装程序——用来在你的机器上安装java或者java工具）。classpath包含一个或多个目录，用来查找.calsspath文件的根目录。从根目录开始，解释器获取包的名称并将每个据点替换为反斜杠，以从classpath根中产生一个路径名称（浴室，package.foo.bar就变成了foo\bar\bar）。得到的路径会与classpath中的各个不同的项项连接，解释器就在这些目录中查询与你要创建的类名相关的.class文件



继承的执行顺序：从基类开始到继承类

垃圾清理的顺利：与清理动作生成顺序相反

##### 继承使用场景

是否需要从新类向基类进行向上转型。

## 多态

##### 动态绑定（后期绑定、运行时绑定）

除了static和final方法，java中其他方法都是后期绑定。运行时根据对象的类型进行绑定。

## 接口

##### 策略设计

创建一个能够根据所传递的参数对象不同而具有不同行为的方法。这类方法包含所要执行的算法中固定不变的部分，而“策略”包含变化的部分。策略就是要传递进去的参数对象，他包含要执行的代码。

## 内部类

##### 创建内部类对象

从外部类的非静态方法之外的任意位置创建某个**内部类**的对象：

1)OuterClassName.INnerClassName

2)使用new语法

```java
public class DotNew(){
    public class Inner{}
    public static void main(String[] args){
        DotNew dn = new DotNew();
        DotNew.Inner dbi = dn.new Inner();
    }
}
```

生成对**外部类对象**的引用，可以使用外部类的名字后面紧跟圆点和this

```java
public class DotThis{
    void f(){
        System.out.printlin("DotThis.f()");
    }
    public class Inner{
    public DotThis outer(){
        return DotThis.this;
    	}
    }
    public Inner inner(){
        return new Inner();
    }
    public static void main(String[] args){
        DotThis dt = new DotThis();
        DotThis.Inner dt1 = dt.inner();
        dt1.outer.f();
    }
}
//output:DotThis.f()

```

#### 嵌套类

如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部声明为static：

1）要创建嵌套类的对象， 并不需要其外围类的对象

2）不能从嵌套类的对象中访问非静态的外围类对象

##### 接口内部的类

如果想要创建某些公共代码，使得他卖的可以被某个接口的所有不同实现所共用，那么可以使用接口内部的嵌套类

```java
public interface ClassTnterface{
    void howdy();
    class Test implements classInterface{
        public void howdy(){
            sout("hoddy");
        }
        public static void main(String[] args){
            new Test().howdy();
        }
    }
}
//Output:hoddy
```

#### 持有对象

HashSet最快的获取元素的方式，TreeSet按照比较结果的升序保存对象，LinkedHashSet按照被添加的顺序保存对象。

HashMap提供了最快的查找技术，TreeMap按照比较结果的升序保存键，LinkedHashMap按照插入顺序保存键，同时还保留了HashMap的查询速度。

##### ListIteraror

Iterator的子类型。可以双向移动，可以产生相对于迭代器在列表中指向的当前位置的前一个和后一个元素的索引，并且可以用set()替换他访问过的最后一个元素。可以通过调用listIterator()方法产生一个指向List开始处的ListIterator，并且可以通过调用listIterator(n)方法创建一个一开始就指向列表索引为n的元素处的ListIterator

##### LinkedList

getFirst() /element():返回列表的头（第一个元素），并不移除他，list为空报错。

peek() list为空时返回null

removeFirst() /remove():移除并返回列表的头，list为空报错

poll()list为空时返回null

## 1. 编程基础

  数据在计算机内部都是二进制表示的，不方便操作，为了方便操作数据，高级语言引入了**数据类型**和**变量**的概念
### 1.1 数据类型和变量

日期在Java中也是一个对象，内部表示为整型long

所谓内存在程序看来就是一块有地址编号的连续的空间，数据放到内存中的某个位置后，为了方便地找到和操作这个数据，需要给这个位置起一个名字。编程语言通过**变量**这个概念来表示这个过程。

在给long类型赋值时，如果常量超过了int的表示范围，需要在常量后面加大写或小写字母L，即L或l，之所以需要加L或l，是因为数字常量默认为是int类型。

日期在Java中也是一个对象，内部表示为整型long

### 1.2 赋值

一个基本类型变量，内存中只会有一块对应的内存空间。但数组有两块：一块用于存储数组内容本身，另一块用于存储内容的位置

### 1.3 条件执行

switch值的类型可以是byte、short、int、char、枚举和String,但不能是long类型，因为跳转表大部分是32位存储

### 1.4 函数调用的基本原理

栈一般是从高位地址向低位地址扩展，换句话说，栈底的内存地址是最高的，栈顶的是最低的。

计算机系统主要使用栈来存放函数调用过程中需要的数据，包括参数、返回地址，以及函数内定义的局部变量。

对于对象和数组，他们都有两块内存，一块存在实际的内容，一块存放实际内存的地址，实际的内容空空一般不是分配在栈上，而是在**堆**，存放地址的空间是分配在**栈**上。

函数调用主要通过栈来存储相关的数据，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单认为是通过一个专门的返回器存储器存储的。

## 2. 理解数据背后的二进制

### 2.1 整数的二进制表示与位运算

整数有4种类型byte short int long,分布占 1 2 4 8个字节，即分别占8 16 32 64位，每种类型的符号位都是其最左边的一位。整数是原码表示法，负数时补码表示法，即在原码表示的基础上取反再加1。

```java
int a = 25;
sout(Integer.toBinaryString(a));//二进制
sout(Integer.toHexString(a));//十六进制
```

### 2.2 位运算

1) 左移：<<,向左移动，右边的低位补0，高位舍弃，相当于乘以2.
2) 无符号右移：>>>，向右移动，右边的舍弃掉，左边补0.
3) 有符号右移：>>，向右移动，右边的舍弃掉，左边补什么取决于原来最高位是什么，相当于除以2

```java
int a = 4;
a = a>> 2;//001，等于1
a = a << 3;//1000,=8
```

### 2.3 char的真正含义

char本质上是一个固定占用两个字节的无符号正整数，这个正整数对应于unicode编号，用于表示那个Unicode编号对应的字符。

# 3. 类的基础

## 3.1 类的基本概念

**Arrays api**

void sort(int[] a):int数组升序排序

int binarySearch(long[] a,long key):二分查找key，数组a需要升序排序

void fill(int[] a,int val):给所有数组元素赋值val

int copyOf(int[] original,int newLength):数组复制

boolean equals(char[] a,char[] a2):判断两个数组是否相同

### 3.1.1 类、方法、变量

类方法只能访问类变量，不能访问实例变量，可以调用其他的类方法，不能调用实例方法。

实例方法既能访问实例变量，也能访问类变量。既可以调用实例方法，也可以调用类方法。

**私有化变量的原因：**

一般而言，不应该将实例变量声明为Public，而值应该通过对象的方法对实例变量进行操作，这也是为了减少误操作，直接访问变量没有办法进行参数检查和控制，而通过方法修改，可以在方法中进行检查。

### 3.1.2 构造方法

**私有化构造方法的场景**

1.  不能创建类的实例，类只能被静态访问，如Math和Arrays类，他们的构造方法就是私有的。
2. 能创建类的实例，但只能被类的静态方法调用，如单例模式
3. 只是用来被其他多个构造方法调用，用于减少重复代码。

### 3.1.3 类和对象的生命周期

对象和数组一样，有两块内存，保存地址的部分分配在栈中，而保存实际内容的部分分配在堆中。栈中的内存是自动管理的，函数调用入栈就会分配，而出栈就会释放。

堆中的内存是被垃圾回收机制管理的，当没有活跃变量指向对象的时候，对应的堆空间就可能被释放，具体释放实际是JVM决定的。活跃变量就是已加载的类的类变量，以及栈中所有的变量。

### 3.1.4 小结

通过类实现自定义数据类型，封装该类型的数据所具有的属性和操作，隐藏实现细节，从而在更高的层次（类和对象的层次，而非基本数据类型和函数的层次）上考虑和操作数据，是计算机程序解决复杂问题的一种重要思维方式。













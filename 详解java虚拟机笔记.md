# 详解java虚拟机

### 1. JVM与Java体系结构

#### JVM的整体结构

![image-20220424154414380](https://gitee.com/liujunrull/image-blob/raw/master/imageBlob/202204241544463.png)

##### java代码执行流程

![image-20220424155549423](https://gitee.com/liujunrull/image-blob/raw/master/imageBlob/202204241556196.png)

解释执行器：保证响应时间

JLT编译器针对热点代码再次解析执行，第一次编译将源文件编译成字节码文件，第二次编译是将字节码文件编译成机器指令，将热点代码缓存，JLT编译器负责程序的性能

#### JVM的架构模型

##### 基于栈式架构的特点

- 设计和实现更简单，适用于资源受限的系统，比如机顶盒
- 不开朗寄存器的分配难题：使用零地址指令方式分配
- 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器更容易实现
- 不需要硬件支持，可移植性更好，更好实现跨平台

##### 基于寄存器架构的特点

- 典型应用是X86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机
- 指令集架构完全依赖硬件，可移植性差
- 性能优秀和执行更高效
- 花费更少的指令去完成一项操作
- 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。



java指令是根据**栈**来设计的，优点是跨平台性、指令集小；缺点是指令多，执行性能比寄存器差



反编译指令：javap

查看正在运行的进行：jps

#### JVM的生命周期

##### 虚拟机的启动

通过引导类加载器（bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现来指定的。 

##### 虚拟机的执行

执行一个所谓的java程序的时候，真正执行的事一个叫做java虚拟机的进程。

##### 虚拟机的退出

除了程序正常运行或者出现错误导致的正常退出，还可以调用Runtime类或者System类的exit方法，或者Runtime类的halt方法。

### 2.类加载子系统

![image-20220424225317436](https://gitee.com/liujunrull/image-blob/raw/master/202204242253562.png)

#### 类的加载过程

##### 加载

1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

##### 加载.class文件的方式

- 从本地系统中直接加载
- 通过网络获取，典型场景：Web Applet
- 从zip压缩包中读取，成为日后jar.war包格式的基础
- 运行时计算生成，使用做多的是：动态代理技术
- 由其他文件生成，典型场景：JSP应用
- 从专有数据库中提取.class文件，比较少见
- 从加密文件中获取，典型的防Class文件被反编译的保护措施

#### 链接

##### 验证

目的在于确保class文件的字节流汇总包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全

主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证

##### 准备

为类变量分配内存并设置该类变量的默认初始值，即零值

这里不包含final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化

这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量会随着对象一起分配到java堆中。

##### 解析

将常量池中的符号引用转化为直接引用的过程

事实上，解析操作往往会伴随着JVM在执行初始化之后再执行

#### 初始化

初始化阶段就是执行类构造器方法<clinit>()的过程

此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中语句合并而来。

构造器方法中指令按语句在源文件中出现的顺序执行

<clinit>不同于类构造器

若该类具有父类，JVM会保证子类的<clinit>执行前，父类的<clinit>()已经执行完毕

虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁

#### 类加载器的分类

##### 虚拟机自带的加载器

- 启动类加载器（引导类加载器，Bootstrap ClassLoader）

  使用C/C++语言实现，嵌套在JVM内部

  用来加载java的和辛苦，提供JVM自身需要的类

  并不继承自java.lang.ClassLoader，没有父类加载器

  加载拓展类和应用程序类加载器，并指定为他们的父类加载器

  出于安全考虑，BootStrap启动类加载器只加载包名为java、javax、sun开头的类

- 扩展类加载器（Extension ClassLoader）

  由java语言编写，由sun.misc.Launcher$ExtClassLoader实现

  派生于ClassLoader类

  父类加载器为启动类加载器

  从java.ext.dirs系统属性所指定的目录中加载类库，或从jdk的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的jar放在此目录下，也会自动由拓展类加载器加载

-  应用程序类加载器（系统类加载器，AppClassLoader）

  由java语言编写，由sun.misc.Launcher$ExtClassLoader实现

  派生于ClassLoader类

  父类加载器为启动类加载器

  它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库

  <u>**程序中默认的类加载器**</u>，一般来说，java应用的类都是由他来完成加载

  通过classLoader#getSystemClassLoader()方法可以获取到该类加载器

- 用户自定义类加载器

  - 为什么要自定义类加载器

    隔离加载类。各个中间件中间引用其他类，类名会一样，防止冲突会自定义类加载器

    修改类加载的方式。再需要的时候对类进行动态加载

    扩展加载源

    防止源码泄露。加密过的源码在解密时可以自定义类加载器来解码

#### 双亲委派机制

![image-20220425110541202](https://gitee.com/liujunrull/image-blob/raw/master/imageBlob/202204251106943.png)

##### 工作原理（责任链机制）

1. 如果一个类加载器收到了类加载请求，他并不会自己先去加载，而是把这个请求委托给父类加载器去执行
2. 如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器
3. 如果父类加载器可以完成类加载任务，则成功返回，倘若父类加载器无法完成此类加载任务，子加载器才会尝试自己去加载，这就是双亲委派模型

##### 优势

- 避免类的重复加载
- 保护核心api防止被篡改

##### 类的主动使用

- 创建类的实例
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射
- 初始化一个类的子类
- Java虚拟机启动时被标明为启动类的类
- JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果，REF_getStatic REF_putStatic REF_invokeStatic句柄对应的类没有初始化，则初始化

### 3.运行时数据区概述及线程

![image-20220425113949551](https://gitee.com/liujunrull/image-blob/raw/master/imageBlob/202204251139668.png)

每个线程独立拥有的：程序计数器、栈、本地栈

线程间共享：堆、堆外内存（永久代或元空间、代码缓存）

### 4.程序计数器（PC寄存器）

PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令

### 5.虚拟机栈

Java Virtual Machine Stack，早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用（入栈出栈）。

生命周期和线程一致

主管Java程序的运行，他保存方法的局部变量（基本数据类型、引用数据类型的地址）、部分结果，并参与方法的调用和返回。

##### 优点

- 速度快，仅次于程序计数器

- jvm对Java栈的操作只有两个

  每个方法执行，伴随着进栈（入栈、压栈）

  执行结束后的出栈工作

- 对于栈来说不存在垃圾回收问题

##### 栈中可能出现的异常

Java虚拟机规范允许Java栈的大小是固定不变的或者是动态的

- 如果是固定不变的，那么每个线程的Java虚拟机栈的容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，会抛出StackOverflowError异常
- 如果是动态的，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程的时候没有足够的内存去创建对应的虚拟机栈，会抛出OutOfMemoryError异常

使用参数-Xss设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度

#### 栈帧的内部结构

- 局部变量表（Local Variables）
- 操作数栈（Operand Stack）（或表达式栈）
- 动态链接（Dynamic Linking）（或指向运行时常量池的方法引用）
- 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）
- 一些附件信息

##### 局部变量表

也被称为局部变量数组或本地变量表

定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用，以及returnAddress类型

由于局部变量表是建立在线程的栈上，是线程的私有数据，所以不存在数据安全问题

局部变量表所需的容量大小是在编译期就确定下来的，并保存在方法的code属性的maximun lical variables数据项中。在方法运行期间不会改变局部变量表的大小的

##### 关于slot

jvm会为局部变量表中的每个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值

double和long类型占据两个slot

当一个实例方法被调用的时候，他的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每个slot上

如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可

如果当前帧时由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，企图的参数按照参数表顺序继续排列

![image-20220428173552303](https://gitee.com/liujunrull/image-blob/raw/master/202204281736986.png)

##### slot的重复利用

栈帧中的局部变量表中的槽位时可以重用的，如果一个局部变量过了其作用域，那么在其作用域后申明的新的局部变量就由可能会复用国企局部变量的槽位，从来达到节省资源的目的

```java
public class SlotTest{
    public void localVar(){
		int a = 0;
        sout(a);
        int b = 0;
    }
    public void localVar1(){
        {
            int a = ;
            sout(a);
        }
        //此时b会复用a的槽位
        int b = 0
    }
}
```

![image-20220428174538723](https://gitee.com/liujunrull/image-blob/raw/master/202204281745784.png)

**成员变量：在使用前都经历过默认初始化赋值**

- 类变量：linking的prepare阶段：给类变量默认复制------》initial阶段：给类变量显示赋值

- 实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认复制

**局部变量：在使用前必须进行显式赋值**

在栈帧中，于性能调优最为密切的就是局部变量表，在方法执行时，虚拟机使用局部变量表完成方法的传递

局部变量表的变量也是重要的垃圾回收根节点，只有被局部变量表中直接或间接引用的对象都不会被回收。

#### 操作数栈，数组结构实现

主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。

操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈（push)和出栈（pop）操作来完成一次数据访问

##### 栈顶缓存技术(HotSpot JVM)

将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。

#### 动态链接（指向运行时常量池的方法引用）

每个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接

在java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。动态里那句的作用就是为了将这些符号引用转换为调用方法的直接引用

![image-20220428185150889](https://gitee.com/liujunrull/image-blob/raw/master/202204281851990.png)

#### 方法的绑定机制

在jvm中，将符号引用转换为调用方法的直接引用与方法的绑定机制有关

静态链接（早期绑定）：目标方法在编译期可知，且运行期保持不变

动态链接（晚期绑定）：被调用的方法在编译期内无法确定下来

**非虚方法**

- 在编译期就确定了具体的调用版本
- 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法
- 其他方法称为虚方法

虚拟机中提供了几条方法调用指令：

1. invokestatic:调用静态方法，解析阶段确定唯一方法版本
2. invokesprcial:调用<init>方法、私有及父类方法，解析阶段确定唯一方法版本
3. invokevirtrual:调用所有虚方法（除final修饰）
4. Invokeinterface:调用接口方法
5. invokedynamic:动态解析出需要调用的方法，然后执行
#### Arrays的实用功能
System.arraycopy(),用它复制数组要比for循环快。

如果是复制对象数组，则只是复制对象的引用，成为浅复制。

不会执行自动包装和自动拆包，两个数组必须有相同的确切类型


**程序设计的基本目标**

将保持不变的事物和发生改变的事物相分离。可以使用策略模式，将会发生改变的代码封装成单独的类（策略对象），可以将策略对象传递给总是相同的代码。例如，用不同的对象来表示不同的比较方式，然后将他们传递给相同的排序代码
#### lis实用方法
* indexOfSubList(List source,List target):返回target在source中第一次出现的位置，找不到返回-1
* lastOfSubList(List source,List target)：返回最后一次出现的位置
* rotate(List,int distance):所有元素向后移动distance个位置，末尾的元素循环到前面来
* swap(List,int i,int j):交换list中位置i与位置j的元素。通常比自己写的代码快
* fill(List<? super T>,T x):用对象x替换list中所有元素
* frequency(Collection,Object x):返回Collection中等于x的元素个数

##### 设置Collection或Map为不可修改
```java
List<String> a = Collections.unmodifiableList(new ArrayList<String> data);
```
使用场景：将容器设为只读前，填入有意义的数据，装在数据后，使用“不可修改的”方法返回的引用替换原来的引用，这样就不用担心无意中修改了只读的内容。另一方面，此方法允许你保留一份可修改的容器，作为类的private成员，然后通过某个方法调用返回对该容器的“只读”的引用。这样一来，只有你可以修改容器的内容，而别人只能读取。
##### Collection或Map的自有同步控制
```java
Collection<String> c = Collections,synchronizedList(new ArrayList<String> data);
```
### IO系统
任何自Inputstream或Reader派生而来的类都含有名为read()的基本方法，用于读取单个字节或者字节数组。同样，任何自OutputStream或Writer派生而来的类都含有名为write()的基本方法，用于写单个字节或者字节数组。但是我们通常不会用到这些方法，他们之所以存在是因为别的类可以使用他们，以便提供更有用的接口。因此，我们很少使用单一的类来创建流对象，而是通过叠合多个对象来提供所期望的功能（这是装饰器设计模式）
#### 标准IO重定向
```java
PrintStream console = System.out;
BufferedInputStream in = new BufferedInputStream(new FileINputStream("readrectiong.java"));
PrintStream out = new PrintStream(new BUfferedOutputStream(new FileOutputStream("test.out")));
System.setIn(in);
System.setOut(out);
System.err(out);
BUfferedReader br = new BufferedReader(new InputStreamReader(System.in));
String s;
while((s = br.readLine()) != null)
sout(s);
out.close();
System.setOut(console);
```
这个程序将标准输入附接到文件上，并将标准输出和标准错误重定向到另一个文件。注意，他在程序开头处存储了队最初的System.out对象的引用，并且在结尾处将系统恢复到了该对象上。
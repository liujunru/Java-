# 详解java虚拟机

### JVM与Java体系结构

#### JVM的整体结构

![image-20220424154414380](https://gitee.com/liujunrull/image-blob/raw/master/imageBlob/202204241544463.png)

##### java代码执行流程

![image-20220424155549423](https://gitee.com/liujunrull/image-blob/raw/master/imageBlob/202204241556196.png)

解释执行器：保证响应时间

JLT编译器针对热点代码再次解析执行，第一次编译将源文件编译成字节码文件，第二次编译是将字节码文件编译成机器指令，将热点代码缓存，JLT编译器负责程序的性能

#### JVM的架构模型

##### 基于栈式架构的特点

- 设计和实现更简单，适用于资源受限的系统，比如机顶盒
- 不开朗寄存器的分配难题：使用零地址指令方式分配
- 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器更容易实现
- 不需要硬件支持，可移植性更好，更好实现跨平台

##### 基于寄存器架构的特点

- 典型应用是X86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机
- 指令集架构完全依赖硬件，可移植性差
- 性能优秀和执行更高效
- 花费更少的指令去完成一项操作
- 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。



java指令是根据**栈**来设计的，优点是跨平台性、指令集小；缺点是指令多，执行性能比寄存器差



反编译指令：javap

查看正在运行的进行：jps

#### JVM的生命周期

##### 虚拟机的启动

通过引导类加载器（bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现来指定的。 

##### 虚拟机的执行

执行一个所谓的java程序的时候，真正执行的事一个叫做java虚拟机的进程。

##### 虚拟机的退出

除了程序正常运行或者出现错误导致的正常退出，还可以调用Runtime类或者System类的exit方法，或者Runtime类的halt方法。

### 类加载子系统

![image-20220424225317436](https://gitee.com/liujunrull/image-blob/raw/master/202204242253562.png)

#### 类的加载过程

##### 加载

1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

##### 加载.class文件的方式

- 从本地系统中直接加载
- 通过网络获取，典型场景：Web Applet
- 从zip压缩包中读取，成为日后jar.war包格式的基础
- 运行时计算生成，使用做多的是：动态代理技术
- 由其他文件生成，典型场景：JSP应用
- 从专有数据库中提取.class文件，比较少见
- 从加密文件中获取，典型的防Class文件被反编译的保护措施

#### 链接

##### 验证

目的在于确保class文件的字节流汇总包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全

主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证

##### 准备

为类变量分配内存并设置该类变量的默认初始值，即零值

这里不包含final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化

这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量会随着对象一起分配到java堆中。

##### 解析

将常量池中的符号引用转化为直接引用的过程

事实上，解析操作往往会伴随着JVM在执行初始化之后再执行

#### 初始化

初始化阶段就是执行类构造器方法<clinit>()的过程

此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中语句合并而来。

构造器方法中指令按语句在源文件中出现的顺序执行

<clinit>不同于类构造器

若该类具有父类，JVM会保证子类的<clinit>执行前，父类的<clinit>()已经执行完毕

虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁

#### 类加载器的分类

##### 虚拟机自带的加载器

- 启动类加载器（引导类加载器，Bootstrap ClassLoader）

  使用C/C++语言实现，嵌套在JVM内部

  用来加载java的和辛苦，提供JVM自身需要的类

  并不继承自java.lang.ClassLoader，没有父类加载器

  加载拓展类和应用程序类加载器，并指定为他们的父类加载器

  出于安全考虑，BootStrap启动类加载器只加载包名为java、javax、sun开头的类

- 扩展类加载器（Extension ClassLoader）

  由java语言编写，由sun.misc.Launcher$ExtClassLoader实现

  派生于ClassLoader类

  父类加载器为启动类加载器

  从java.ext.dirs系统属性所指定的目录中加载类库，或从jdk的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的jar放在此目录下，也会自动由拓展类加载器加载

-  应用程序类加载器（系统类加载器，AppClassLoader）

  由java语言编写，由sun.misc.Launcher$ExtClassLoader实现

  派生于ClassLoader类

  父类加载器为启动类加载器

  它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库

  <u>**程序中默认的类加载器**</u>，一般来说，java应用的类都是由他来完成加载

  通过classLoader#getSystemClassLoader()方法可以获取到该类加载器

- 用户自定义类加载器

  - 为什么要自定义类加载器

    隔离加载类。各个中间件中间引用其他类，类名会一样，防止冲突会自定义类加载器

    修改类加载的方式。再需要的时候对类进行动态加载

    扩展加载源

    防止源码泄露。加密过的源码在解密时可以自定义类加载器来解码

#### 双亲委派机制

![image-20220425110541202](https://gitee.com/liujunrull/image-blob/raw/master/imageBlob/202204251106943.png)

##### 工作原理（责任链机制）

1. 如果一个类加载器收到了类加载请求，他并不会自己先去加载，而是把这个请求委托给父类加载器去执行
2. 如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器
3. 如果父类加载器可以完成类加载任务，则成功返回，倘若父类加载器无法完成此类加载任务，子加载器才会尝试自己去加载，这就是双亲委派模型

##### 优势

- 避免类的重复加载
- 保护核心api防止被篡改

##### 类的主动使用

- 创建类的实例
- 访问某个类或接口的静态变量，或者对该静态变量赋值
- 调用类的静态方法
- 反射
- 初始化一个类的子类
- Java虚拟机启动时被标明为启动类的类
- JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果，REF_getStatic REF_putStatic REF_invokeStatic句柄对应的类没有初始化，则初始化

### 运行时数据区概述及线程

![image-20220425113949551](https://gitee.com/liujunrull/image-blob/raw/master/imageBlob/202204251139668.png)

每个线程独立拥有的：程序计数器、栈、本地栈

线程间共享：堆、堆外内存（永久代或元空间、代码缓存）

### 程序计数器（PC寄存器）

PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令

### 虚拟机栈